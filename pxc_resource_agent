#!/usr/bin/perl

use Data::Dumper;

use constant {
	# Pacemaker RA standard exit codes
	OCF_SUCCESS => 0,
	OCF_ERR_GENERIC => 1,
	OCF_ERR_ARGS => 2,
	OCF_ERR_UNIMPLEMENTED => 3,
	OCF_ERR_PERM => 4,
	OCF_ERR_INSTALLED => 5,
	OCF_ERR_CONFIGURED => 6,
	OCF_ERR_NOT_RUNNING => 7,
	OCF_RUNNING_MASTER => 8,
	OCF_FAILED_MASTER => 9,
	
	# Internal debugging levels
	LOG_DEBUG => 5,
	LOG_INFO => 4,
	LOG_WARN => 3,
	LOG_CRIT => 2,
	LOG_FATAL => 1,
	
	# CLI tools
	CRM_MASTER_CLI => "/usr/sbin/crm_master",
	CRM_ATTR => "/usr/sbin/crm_attribute",
	CIBADMIN => "/usr/sbin/cibadmin",
	
	MYSQL_CLI => "/usr/bin/mysql",
	SERVICE_MYSQL_CLI => "/sbin/service mysql",	
	MYSQLD_SAFE => "/usr/bin/mysqld_safe",
	
	HOSTNAME => "/usr/sbin/crm_node -n",
	
	# Grastate path
	GRASTATE => "/var/lib/mysql/grastate.dat",
	
	# Misc settings
	BOOTSTRAP_TIMEOUT => 60,
};

use vars qw { @ARGV %ENV $LOG_LEVEL };


#####
# Logging 
#####

# $LOG_LEVEL = LOG_DEBUG;
$LOG_LEVEL = LOG_INFO;

my $log = "/tmp/pxc_resource_agent.log";
open( LOG, ">> $log" ) or die "Could not open logfile: $log\n";

sub print_log {
	my $date = `date`; chop $date;
	print LOG $date . " " . join( ' ', @_ ) . "\n";
}

sub debug {
	return if $LOG_LEVEL < LOG_DEBUG;
	print_log( "DEBUG", @_);
}
sub info {
	return if $LOG_LEVEL < LOG_INFO;
	print_log( "INFO", @_ );
}
sub warning {
	return if $LOG_LEVEL < LOG_WARN;
	print_log( "WARN", @_ );
}
sub error {
	return if $LOG_LEVEL < LOG_ERROR;
	print_log( "ERROR", @_ );
}


####
# Utility functions
####

# Fork a system call and get a string for the output
# $name: unique id for this command (for logging output)
# $command: the command to run
# $ok_rcs: return codes that should not through an exception (default: ['0'])
sub unix_exec_string {
	my( $name, $cmd, $acceptable_rcs ) = @_;
	
	$acceptable_rcs = [ 0 ] unless defined $acceptable_rcs;
	
	debug( "running $name: $cmd" );
	my $output = `$cmd`; chop $output;
	my $rc = $? >> 8;
	
	debug( Dumper( $acceptable_rcs ));
		
	if( scalar grep {$_ == $rc} @$acceptable_rcs ) {
		debug( "$name rc: $rc");
		debug( "$name output: '$output'");
	} else {
	 	die "$name failed: $rc!\n";		
	}
	
	return $output;
}

sub unix_exec_ok {
	eval{ unix_exec_string( @_ )};
	return !$@;
}

# Get a mysql global status variable (if mysql is running)
sub mysql_global_status {
	my $variable = shift @_;
	return unix_exec_string( 'mysql global status', 
		MYSQL_CLI . ' --skip-column-names -Be "select variable_value from information_schema.global_status where variable_name=\'' . $variable . '\'"' 
	);
}

# tell pacemaker this node may or may not be a master
sub master_ok {
	return unix_exec_string( 'crm master', CRM_MASTER_CLI . ' -l reboot -v 1' );
}
sub master_not_ok {
	return unix_exec_string( 'crm master', CRM_MASTER_CLI . ' -l reboot -D' );
}

# Node-specific attributes
sub crm_attr_set {
	my( $name, $value ) = @_;

	return unix_exec_ok( 'crm attr set', 
		CRM_ATTR . " -l reboot --name $name-" . $ENV{'OCF_RESOURCE_INSTANCE'} . " -v $value"
	);
}
sub crm_attr_delete {
	my( $name ) = @_;
	return unix_exec_ok( 'crm attr delete', 
		CRM_ATTR . " -l reboot --name $name-" . $ENV{'OCF_RESOURCE_INSTANCE'} . " --delete"
	);
}
sub crm_attr_get {
	my( $name ) = @_;
	
	return unix_exec_string( 'crm attr get', 
		CRM_ATTR . " -l reboot --name $name-" . $ENV{'OCF_RESOURCE_INSTANCE'} . " --query -q"
	);
}

# Query CIB for all attributes for THIS resource
sub cib_query_attribute {
	my( $name ) = @_;
	
	my $cmd = CIBADMIN . ' --query --xpath "//status/node_state/transient_attributes/*/nvpair[@name = \"' . $name . '-' . $ENV{'OCF_RESOURCE_INSTANCE'} . '\"]"';

	debug( "cibadmin call: $cmd" );
	my @output = `$cmd`;
	my $rc = $? >> 8;
	
	debug( "cibadmin call rc: $rc");
 	die "cibadmin call failed: $rc" if $rc > 0 and $rc != 6;
	

	my $count = 0;
	my %matches;
	foreach my $line( @output ) {
		debug( $line );
		if( $line =~ m/$name/ ) {
			$line =~ m/status-(\w+)-$name/;
			my $key = $1;
			
			$line =~ m/value=\"(.*)\"/;
			my $value = $1;
			
			$matches{$key} = $value;
			$count++;
		}
	}
	
	return \%matches;
}

# check service status
sub service_mysql_running {
	return unix_exec_ok( 'service mysql status', SERVICE_MYSQL_CLI . ' status' );
}

# issue service command
sub service_mysql {
	my $command = shift @_;
	return unix_exec_ok( "service mysql $command", 
		SERVICE_MYSQL_CLI . ' ' . $command );
}


##### 
# OCF action handlers
#####

sub pxc_monitor {
	# Check local PXC instance		
	my $local_state = undef;
	my $rc = OCF_ERR_GENERIC;
	eval {
		$local_state = mysql_global_status( 'wsrep_local_state_comment' );
	};
	if( $@ or !defined( $local_state ) ) {
		warning( "global status problem: $@" );
		master_not_ok();
		crm_attr_delete( 'pxc_running' );
		
		# Check the service to see if it is running
 		if( !service_mysql_running() ) {
			$rc = $ENV{'OCF_RESKEY_CRM_meta_role'} eq 'Master' ? 
				OCF_FAILED_MASTER : OCF_ERR_NOT_RUNNING;
 		} else {
			$rc = OCF_ERR_GENERIC;
		}
	} elsif( $local_state eq 'Synced' ) {		
		if( $ENV{'OCF_RESKEY_CRM_meta_role'} eq 'Master') {
			debug( "already a master, normal" );	
			crm_attr_set( 'pxc_running', "master" );
			$rc = OCF_RUNNING_MASTER;			
		} else {
			# This node can be promoted to "master"
			debug( "not a master, but could be" );
			master_ok();
			$rc = OCF_SUCCESS;
		}
	} elsif( $local_state eq 'Donor/Desynced') {
		debug( "donor/desynced node" );
		master_not_ok();
		crm_attr_set( 'pxc_running', "slave" );
		$rc = OCF_SUCCESS;
	}
	
	# Clear out the GTID every monitor just to be sure we never get a stale value
	pxc_clear_gtid();
	
	if( $rc == OCF_SUCCESS or $rc == OCF_RUNNING_MASTER ) {
		info( "monitor results: $local_state" );
	} else {
		error( "monitor results: $local_state" );
	}
	return $rc;
}

sub are_we_cool {
	my $state = pxc_monitor();
	if( $state == OCF_RUNNING_MASTER or $state == OCF_SUCCESS ) {
		# Promote already done for us
		return OCF_SUCCESS;
	} else {
		return $state;
	}
}
sub pxc_promote {
	debug( "promote action" );
	return are_we_cool();
}

sub pxc_demote {
	debug( "demote action" );
	return are_we_cool();
}

sub pxc_start {
	info( "start action" );
	
	if( service_mysql_running() ) {
		info( "PXC already running" );
		return OCF_SUCCESS;
	} else {
		# Are there any other nodes in the cluster?
		if( keys %{cib_query_attribute('pxc_running')} == 0 ) {
			info( "No other nodes visibly running, trying bootstrap" );
			
			return pxc_bootstrap();
		} else {
			info( "Other nodes report running, skip bootstrap" );
			
			service_mysql( 'stop' ); # clean out any pid files
			if( service_mysql( 'start' )) {	
				return OCF_SUCCESS;
			} else {
				error( "service mysql got error" );
				return OCF_ERR_GENERIC;
			}
		}		
	}	
}

# Special case:  When there are no other clones, we need to figure out who can start first
sub pxc_bootstrap {
	# First, calculate our GTID and store it in the CIB
	pxc_get_gtid();
	info( "GTID: " . crm_attr_get( 'pxc_uuid') . ':' . crm_attr_get( 'pxc_seqno' ));
	
	# Second, wait until all nodes show a GTID OR a timeout happens
	my $timeout = BOOTSTRAP_TIMEOUT;
	my $seqnos = cib_query_attribute( 'pxc_seqno' );
	while( keys %$seqnos < $ENV{'OCF_RESKEY_CRM_meta_clone_max'} and $timeout > 0 ) {
		info( keys( %$seqnos ) . " out of " . $ENV{'OCF_RESKEY_CRM_meta_clone_max'} . " have submitted GTIDs, waiting for the rest... ($timeout s)");
		sleep 1;
		$timeout--;
		$seqnos = cib_query_attribute( 'pxc_seqno' );
	}
	if( keys %$seqnos < $ENV{'OCF_RESKEY_CRM_meta_clone_max'} ) {
		warn( "Timeout exceeded, continuing bootstrap without all the nodes." );
	} else {
		info( "Got GTIDs from all nodes" );
	}
	
	# Third, find the node with the biggest GTID
	my $seqnos = cib_query_attribute( 'pxc_seqno' );
	my $most_ahead = undef;
	for my $node( sort keys %$seqnos ) {
		my $seqno = $seqnos->{$node};
		if( !defined( $most_ahead ) or $seqno > $seqnos->{$most_ahead} ) {
			$most_ahead = $node;
		}
	}	
	
	# 3b: need to sanity check the UUIDs here
	# FIXME
	
	# Fourth, if the most ahead is US, then we bootstrap
	my $hostname = unix_exec_string( 'get_hostname', HOSTNAME );
	
	info( "furthest ahead GTID: $most_ahead, us: $hostname");
	if( $most_ahead eq $hostname ) {
		info( "Bootstrapping PXC...");		
		if( service_mysql( 'bootstrap-pxc' )) { 
			crm_attr_set( 'pxc_running', 'bootstrapped' );
			return OCF_SUCCESS;
		} else {
			error( "service mysql got error" );
			return OCF_ERR_GENERIC;
		}
	} else {
		info( "Letting $most_ahead bootstrap, waiting..." );

		while( keys %{cib_query_attribute('pxc_running')} == 0 ) {
			sleep 1;
		}
		return pxc_start();
	}
}

# Get the GTID of the local node and store it in a node attribute
sub pxc_get_gtid {
	# return;
	my ($uuid, $seqno) = (undef, undef);
	
	# Start with running instance
	if( service_mysql_running() ) {
		 $uuid = mysql_global_status( 'wsrep_local_state_uuid' );
		 $seqno = mysql_global_status( 'wsrep_last_committed' );
	} else {
		# If not running, check grastate
		eval {
			my @output = split( /\n/, 
				unix_exec_string( 'grastate', 'cat ' . GRASTATE )
			);
			for my $line( @output ) {
				if( $line =~ m/uuid:\s+(.+)/) {
					$uuid = $1;
				} elsif( $line =~ m/seqno:\s+(.+)/ ) {
					$seqno = $1;
				}
			}
		};
		
		if( $@ or $seqno == -1 or !defined( $seqno )) {
			# Lastly, try --wsrep_recover	
			warning( "Trying --wsrep_recover" );
			eval {
				my @output = split( /\n/, unix_exec_string( 
					'wsrep_recover', 
					MYSQLD_SAFE . ' --wsrep_recover' 
				));
			
				foreach my $line( @output ) {
					if( $line =~ m/Recovered position ([\w\-]+)\:([\-\d]+)/ ) {
						$uuid = $1; $seqno = $2;
					} else {
						debug( "NO MATCH: " . $line );
					}
				}
			};
		}
	}
	
	if( $@ or ( !defined( $uuid ) or !defined( $seqno ))) {
		error( "Could not get local GTID: $@" );
		crm_attr_set( 'pxc_uuid', 0 );
		crm_attr_set( 'pxc_seqno', 0 );
			
	} else {
		debug( "gtid: $uuid:$seqno");

		crm_attr_set( 'pxc_uuid', $uuid );
		crm_attr_set( 'pxc_seqno', $seqno );
	}
}

sub pxc_clear_gtid {
	crm_attr_delete( 'pxc_uuid' );
	crm_attr_delete( 'pxc_seqno' );		
}


# NEED:
# - valiation of configuration and environment
# - user/pass variables?
# - other config variables? (e.g., timeout)

# Main block
eval {
	my $command = $ARGV[0];
	debug( "ARGV: " . Dumper( \@ARGV ));
	debug( "ENV: " . Dumper( \%ENV ));
	debug( "Command: $command");
	
	my $rc = OCF_SUCCESS;
	if( $command eq 'monitor') {
		$rc = pxc_monitor();
	} elsif( $command eq 'promote') {
		$rc = pxc_promote();
	} elsif( $command eq 'demote') {
		$rc = pxc_demote();
	} elsif( $command eq 'start') {
		$rc = pxc_start();
	} else {
		info( "$command: noop");
	}
	
	debug( "$command: $rc" );
	
	close( LOG );
	exit $rc;
	
};

if( $@ ) {
	error( $@ );
	close( LOG );
	exit OFC_ERR_GENERIC;
}